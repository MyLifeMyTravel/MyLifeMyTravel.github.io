{"meta":{"title":"厉圣杰的博客","subtitle":"啦啦啦，德玛西亚","description":"希望有一天我能够很坦然地说：\"让我来告诉你，在我眼中，这是一个怎样的世界。\"","author":"厉圣杰","url":"http://www.littlejie.com"},"pages":[{"title":"categories","date":"2017-02-10T09:13:56.000Z","updated":"2017-02-10T09:14:34.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.littlejie.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-10T09:12:40.000Z","updated":"2017-02-10T09:13:38.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.littlejie.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 获取浏览器当前分享页面截屏","slug":"Android-获取浏览器当前分享页面截屏","date":"2017-02-20T11:49:07.000Z","updated":"2017-02-20T11:49:50.000Z","comments":true,"path":"2017/02/20/Android-获取浏览器当前分享页面截屏/","link":"","permalink":"http://www.littlejie.com/2017/02/20/Android-获取浏览器当前分享页面截屏/","excerpt":"","text":"Android 获取浏览器当前分享页面的截屏 版权声明：本文为博主原创文章，未经博主允许不得转载。微博：厉圣杰源码：AndroidDemo/BrowserScreenShotActivity文中如有纰漏，欢迎大家留言指出。 今天在项目中碰见这么一个需求：获取 Chrome 浏览器分享时，页面的截屏。静下来一想，既然是分享，那么肯定得通过 Intent 来传递数据，如果真的能获取到 Chrome 分享页面时的截屏，那么 Intent 的数据中，一定有 .jpg 或者 .png 结尾的数据。说干就干，Demo 写起来。 首先，新建一个 BrowserScreenShotActivity.java，在 AndroidManifest.xml 注册一下 &lt;intent-filter&gt;。 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.littlejie.demo\"&gt; &lt;!-- 读写权限 --&gt; &lt;!-- 用于读取浏览器分享时生成的屏幕截图 --&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; &lt;application android:name=\".modules.DemoApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;!-- some other thing --&gt; &lt;!-- 注册 Intent，用于接受浏览器分享 --&gt; &lt;activity android:name=\".modules.advance.BrowserScreenShotActivity\" android:launchMode=\"singleTask\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;!-- 发送多个数据 --&gt; &lt;action android:name=\"android.intent.action.SEND_MULTIPLE\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"*/*\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 接下去，在浏览器中随便打开一个页面，分享至 Demo，这里有个问题，就是：屏幕截图数据在 Intent 中对应的 Key 我们并不知道，那怎么办呢？打断点啊！ 屏幕快照 通过断点查看 Intent 的数据结构，发现 Intent 中的 mMap 成员变量含有一个 Uri，格式如下：content://com.android.chrome.FileProvider/BlockedFile_33215122012582，一眼看去就猜测这个 Uri 是 Chrome 通过 ContentProvider 供其他程序调用的，虽然与一开始猜测有已 .jpg 和 .png 结尾的数据不太一致，但好歹是有所发现。 恩，现在还有一个问题，那就是 mMap.value[3] 对应的 key 值是多少？在上述断点界面根本就差看不到，但是 Android Studio 是很强大的，只是你没发现而已，既然 mMap 是一个 Map，那么久能通过 keySet() 方法获取 Map 的 key。接下来就是 Android Studio 大展拳脚的时间。 屏幕快照 如上图所示的，在 Debug 界面，点击最后一个图标:Evaluate Expression（快捷键：option + f8）。在弹出的对话框中输入如下内容，回车，你会发现 Map 的 key 都出来了： 屏幕快照 通过与第一幅图对比，发现下标为3的值（share_screenshot_as_stream）为我们需要的 key。 布局比较简单，这里就不贴了，简单截取 BrowserSrceenShotActivity.java 中的代码： 123456789101112131415161718192021@Overrideprotected void onResume() &#123; super.onResume(); if (getIntent() == null) &#123; return; &#125; Uri screenShot = getIntent().getExtras().getParcelable(\"screen_shot_as_stream\"); if (screenShot == null) &#123; ToastUtil.showDefaultToast(\"获取浏览器截屏失败~\"); return; &#125; try &#123; //通过 Uri 获取截屏图片的输入流 InputStream is = getContentResolver().openInputStream(screenShot); mIvScreenShot.setImageBitmap(BitmapFactory.decodeStream(is)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 运行结果如下： screenshot 对于获取 Chrome 浏览器分享页面的截屏就告一段落，闲着没事，自己又测试了几个浏览器，包括系统内置浏览器、QQ浏览器、UC浏览器、百度浏览器、火狐浏览器，发现每个浏览器的差异很大。 系统浏览器、UC浏览器与 Chrome 相差不大，只是 key 变成了 share_full_screen 和 file QQ浏览器的分享行为与分享文件很相似，其 key 为 android.intent.extra.STREAM(Intent.EXTRA_STREAM)。 百度浏览器是个什么鬼就不知道了，默默的把应用图标给分享过来了 火狐浏览器不支持分享页面截图 恩，就这么多，获取浏览器分享页面截屏主要还是靠浏览器的支持，真的市面上这么多浏览器适配起来还真麻烦。这次主要对 Android Studio 强大的 Debug功能进行了学习。PS：Android Studio真是极其强大的工具，用好它事半功倍，唯一不足的就是太耗性能。 Demo 代码传送门","categories":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/tags/Android/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.littlejie.com/tags/浏览器/"}]},{"title":"Android 开发规范","slug":"Android-开发规范","date":"2017-02-13T12:15:23.000Z","updated":"2017-02-13T23:47:28.000Z","comments":true,"path":"2017/02/13/Android-开发规范/","link":"","permalink":"http://www.littlejie.com/2017/02/13/Android-开发规范/","excerpt":"","text":"个人总结的 Android 开发规范初稿，其中控件缩写及 Android 资源文件命名部分不是很确定，有待商榷。Java 部分编程风格请参考：Google Java 命名规范。 2017-02-13 更新：2017年开春之际，诚意献上重磅大礼：阿里巴巴Java开发手册，首次公开阿里官方Java代码规范标准。这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本。点此下载 约定 统一调整 IDE 的编码方式为 UTF-8 01 统一调整 IDE 的 Tab 缩进为 4 个空格 0 花括号不要单独一行，和它前面的代码同一行。而且，花括号与前面的代码之间用一个空格隔开。 1234567891011public void method() &#123; // Good &#125; public void method()&#123; // Bad&#125; public void method()&#123; // Bad &#125; 空格的使用：if、else、for、switch、while等逻辑关键字与后面的语句留一个空格隔开。 12345678910111213141516171819202122// Goodif (booleanVariable) &#123; // TODO while booleanVariable is true&#125; else &#123; // TODO else&#125; // Badif(booleanVariable) &#123; // TODO while booleanVariable is true&#125;else &#123; // TODO else&#125;// 运算符两边各用一个空格隔开。int result = a + b; //Good, = 和 + 两边各用一个空格隔开int result=a+b; //Bad,=和+两边没用空格隔开// 方法的每个参数之间用一个空格隔开。public void method(String param1, String param2); // Good，param1后面的逗号与String之间隔了一个空格public void method(param1, param2); // Good，方法调用时，param1后面的逗号与param2之间隔了一个空格public void method(param1,param2); // Bad，没有用一个空格隔开 空行的使用，拒绝拖沓无分割，关联代码段放一块并与后面代码分割 两个方法之间 方法内的两个逻辑段之间 方法内的局部变量和方法的第一条逻辑语句之间 常量和变量之间 方法名和方法内第一条语句不要有空格 Activity.onCreate()，Fragment.onActivityCreated()，作为程序入口，不要写入太多代码，尽量保持只调用 initXXX() 方法，简单明了展示调用过程。如：initData()，initView()。可在 BaseActivity 、 BaseFragment 中实现 init 执行顺序，子类实现，即 模板方法模式。 Application 中只执行应用初始化相关操作，尽量不要涉及业务逻辑。如有，请单独剥离。参考第 6 条 单个方法体不要过长，最好不要超过一屏，竖屏显示器请无视~ 一行声明一个变量，不要一行声明多个变量，这样有利于写注释。 代码任何地方不要拼错单词 代码必须格式化 12Windows：CTRL + ALT + LMac：OPTION + COMMAND + L 文字大小的单位统一用 sp，元素大小的单位统一用 dp；应用中的字符串统一在 /values/strings.xml 中定义；颜色值统一在 /values/colors.xml 中定义；菜单定义统一放在 /menu/****.xml 中；自定义View 属性统一在 /values/attrs.xml 中；自定义drawable 文件统一在 /drawable/****.xml 中；自定义样式统一在 /values/styles.xml。 调用方法保持“临近原则”，被调用的方法，放在调用方法下方 用好 TODO 标记 记录想法，记录功能点，开发过程中可以利用 TODO 记录一下临时想法或为了不打扰思路留下待完善的说明 删除无用 TODO ，开发工具自动生成的 TODO ，或则已经完善的 TODO ，一定要删除。 处理“魔法数字”等看不懂的神秘数字 代码中不要出现数字，特别是一些标识不同类型的数字。 所有意义数字全部抽取到 Constant 公共类中，避免散布在各位类中。 所有有意义的字符串公共常量全部抽取到 Constant 公共类中 命名规范命名除了要遵守以下规范，还得见名知意。 类和接口命名使用大驼峰规则，用名词或名词词组命名，每个单词的首字母大写。以下为几种常用类的命名： Activity 类，命名以 Activity 为后缀，如：LoginActivity Fragment 类，命名以 Fragment 为后缀，如：LoginFragment Service 类，命名以 Service 为后缀，如：DownloadService Adapter 类，命名以 Adapter 为后缀，如：CouponAdapter 工具类，命名以 Util 为后缀，如：EncryptUtil 模型类，命名以 Info 为后缀，如：UserInfo 接口实现类，命名以 Impl 为后缀，如：ApiImpl 方法命名使用小驼峰规则，用动词命名，第一个单词的首字母小写，其他单词的首字母大写。以下为几种常用方法的命名： 初始化方法，命名以 init 开头，例：initView() 按钮点击方法或 Activity 跳转方法，命名以 to 开头，例：toLogin()、toMainActivity() 设置方法，命名以 set 开头，例：setData() 具有返回值的获取方法，命名以 get 开头，例：getData() 通过异步加载数据的方法，命名以 load 开头，例：loadData() 布尔型的判断方法，命名以 is 或 has ，或具有逻辑意义的单词如 equals ，例：isEmpty() 常量命名全部为大写单词，单词之间用下划线分开。常量一般放在 Constant 类 Intent 参数以 PARAM_EXTRA 开头 1234// Intent 参数public final static String PARAM_EXTRA_ID = \"id\";public final static int PAGE_SIZE = 20; 变量命名使用驼峰规则，首字母必须小写，使用名词或名词词组。要求简单易懂，富于描述，不允许出现无意义或错误单词。 成员变量命名以 mCamelCase 样式命名 boolean 类型的成员变量命名可以不遵循第一条，以 lowerCamelCase 样式命名 控件变量命名都已 控件缩写 + 控件作用 来命名，如：登录按钮命名为 mBtnLogin； 参数变量、临时变量都已 lowerCamelCase 样式命名 123456789public class MainActivity extends Activity &#123; private Button mBtnLogin; private boolean isLaunch; private boolean isEmpty(String text) &#123; // Todo... &#125;&#125; 控件缩写常见控件缩写约定如下： TextView: tv EditText: edt Button: btn RadioButton: rb ImageButton: ib ImageView: iv RelativeLayout/LinearLayout/FrameLayout: rl , ll , fl ListView: lv WebView: web CheckBox: cbx 控件 id 命名控件缩写_含义，范围可选，只在有明确定义的范围内才需要加上。 123456789&lt;!-- 这是标题栏的标题 --&gt;&lt;TextView android:id=\"@+id/tv_header_title\" ... /&gt; &lt;-- 这是登录按钮 --&gt;&lt;Button android:id=\"@+id/btn_login\" ... /&gt; 布局文件命名 Activity 布局：activity_类名.xml，建议使用 Android Studio 生成 Fragment 布局：fragment_类名.xml 控件布局：widget_控件名.xml Adapter Item 布局：item_适配器名.xml strings.xml 命名类型{范围}功能，范围可选。以下为几种常用的命名： 页面标题，命名格式为：title_页面 按钮文字，命名格式为：btn_按钮事件 标签文字，命名格式为：label_标签文字 选项卡文字，命名格式为：tab_选项卡文字 消息框文字，命名格式为：toast_消息 编辑框的提示文字，命名格式为：hint_提示信息 图片的描述文字，命名格式为：desc_图片文字 对话框的文字，命名格式为：dialog_文字 menu 的 item 文字，命名格式为：menu_文字 colors.xml 命名前缀{控件}{范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。 背景颜色，添加 bg 前缀 文本颜色，添加 text 前缀 分割线颜色，添加 div 前缀 区分状态时，默认状态的颜色，添加 normal 后缀 区分状态时，按下时的颜色，添加 pressed 后缀 区分状态时，选中时的颜色，添加 selected 后缀 区分状态时，不可用时的颜色，添加 disable 后缀 drawable的命名前缀{控件}{范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。 图标类，添加 ic 前缀 背景类，添加 bg 前缀 分隔类，添加 div 前缀 默认类，添加 def 前缀 区分状态时，默认状态，添加 normal 后缀 区分状态时，按下时的状态，添加 pressed 后缀 区分状态时，选中时的状态，添加 selected 后缀 区分状态时，不可用时的状态，添加 disable 后缀 多种状态的，添加 selector 后缀（一般为 ListView 的 selector 或按钮的 selector ） 注释规范类和接口注释类和接口统一添加javadoc注释，格式如下： 123456789/** * 类或接口的描述信息 * * @author $&#123;USER&#125; * @date $&#123;DATE&#125; */ public interface Login &#123; &#125; 方法注释下面几种方法，都必须添加注释，说明该方法的用途和参数说明，以及返回值。如不添加注释，方法和参数命名都要见名知意 接口中定义的所有方法 抽象类中自定义的抽象方法 抽象父类的自定义公用方法 工具类的公用方法 12345678/** * 登录 * * @param loginName 登录名 * @param password 密码 * @param listener 回调监听器 */public void login(String loginName, String password, ActionCallbackListener listener); 变量和常量注释下面几种情况下的常量和变量，都要添加注释说明，优先采用 右侧// 来注释，若注释说明太长则在上方添加注释。 接口中定义的所有常量 公有类的公有常量 枚举类定义的所有枚举常量 实体类的所有属性变量 1234567public static final int TYPE_CASH = 1; // 现金券public static final int TYPE_DEBIT = 2; // 抵扣券public static final int TYPE_DISCOUNT = 3; // 折扣券 private int id; // 券idprivate String name; // 券名称private String introduce; // 券简介 发布及安全版本管理版本管理一般使用 Git 打包前必须pull一下代码 打包发版后，打上tag，push代码 打包后记得保存未加密过的包和mapping文件 建议使用 Git 进行版本管理，正式打包前先 pull 一下代码，保证发布版本为最新代码；版本发布后，打 tag 并 push 到服务器 正式版本需要打开 混淆，防止被反编译，gradle 项目在 buildTypes 中配置，混淆的配置文件为 proguard-android.txt 12345678910111213141516//必须在productFlavors之后buildTypes &#123; release &#123; //开启混淆 minifyEnabled true //打包时移除不用资源 shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //不同渠道使用不同的签名 signingConfig signingConfigs.sign &#125; debug &#123; signingConfig signingConfigs.sign &#125;&#125; 正式版本发布时需要关闭 Log ，防止 Log 调试信息的打印造成重要数据泄露。一般思路为封装 LogUtil，在其中根据 BuildConfig.Debug 判断是否输出日志 测试第三方SDK时，如对签名有要求，可以在 debug 时使用正式签名 正式发布版本时，可用第三方工具加密，如：360加密、爱加密，加密后最好测试下，可能会有兼容性问题 打包后记得保存未加密的包并保存 mapping 文件(列出了原始的类，方法和字段名与混淆后代码间的映射) 其它 控制语句 减少条件嵌套，不要超过3层 1234// Badif(obj != null) &#123; doSomething(); &#125;// Goodif(obj == null) &#123; return; &#125; doSomething(); if语句必须用{}包括起来,即便是只有一句 方法 拆分臃肿方法，每个方法只作一件事 做同一个逻辑的方法，尽量靠近放到一块，方便查看 尽量不要使用 try catch 处理业务逻辑 使用JSON工具类，不要手动解析和拼装数据，如：Gson 重构相关书籍 《重构-改善既有代码的设计》 参考关于 colors.xml 和 drawable 命名很久之前摘自某篇博文，忘记具体链接了，如有侵权，请联系我~ 邮箱：1025263614@qq.com","categories":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"http://www.littlejie.com/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/tags/Android/"},{"name":"开发规范","slug":"开发规范","permalink":"http://www.littlejie.com/tags/开发规范/"}]},{"title":"Gradle 实现 Android 多渠道定制化打包","slug":"Gradle-实现-Android-多渠道定制化打包","date":"2016-10-01T04:12:43.000Z","updated":"2017-02-13T23:48:58.000Z","comments":true,"path":"2016/10/01/Gradle-实现-Android-多渠道定制化打包/","link":"","permalink":"http://www.littlejie.com/2016/10/01/Gradle-实现-Android-多渠道定制化打包/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 最近在项目中遇到需要实现 Apk 多渠道、定制化打包， Google 、百度查找了一些资料，成功实现了上述功能，在此记录以备不时之需，温故而知新，可以为师矣~ 需求可以总结如下： 多渠道打包 如何实现多个 Apk 安装在同一设备在之前的印象中，同一个应用在同一设备上只能安装一个，除非手动修改 AndroidManifest.xml 文件中的包名（ package ），但这么做的后果就是新的应用真的是新的应用，旧版应用再也收不到更新。而现在你通过 Gradle，你可以轻松构建多个不同版本的应用，并且在同一设备上安装使用。 这里要用到 productFlavors ，productFlavors 可以用来自定义应用构建版本，我们可以用其 applicationId 属性来实现多个 Apk 安装在同一设备上。 build.gradle 中部分配置代码如下： 1234567891011121314151617181920212223242526272829303132333435android &#123; compileSdkVersion 24 buildToolsVersion \"24.0.1\" //默认配置,所有 productFlavors 都会继承 defaultConfig 中配置的属性 defaultConfig &#123; //默认的 applicationId,一般与 AndroidManifest.xml 文件 package属性相同 applicationId \"com.littlejie.multichannel\" minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName \"1.0\" &#125; // productFlavors 定义了一个应用的自定义构建版本 //一个单一的项目可以同时定义多个不同的 flavor 来改变应用的输出。 // productFlavors 这个概念是为了解决不同的版本之间的差异非常小的情况，通常用于区分同一个应用的不同渠道/客户等，可包含少量业务功能差别。 // productFlavors 中的 flavor 不能跟 buildType 中的一样,否则会报: \"ProductFlavor names cannot collide with BuildType names\" productFlavors &#123; //默认版本,不设置 applicationId ,继承 defaultConfig 中的配置 flavors_default &#123; &#125; //开发版本, applicationId 替换为 com.littlejie.multichannel.dev flavors_dev &#123; applicationId \"com.littlejie.multichannel.dev\" &#125; //发布版本, applicationId 替换为 com.littlejie.multichannel.release flavors_release &#123; applicationId \"com.littlejie.multichannel.release\" &#125; &#125;&#125; MainActivity.java: 123456789101112public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, \"package name = \" + this.getPackageName()); &#125;&#125; 在 Android Studio 中执行如下命令： 12//打 debug 包，gradle 命令会在后面 `gradle task`中详细讲述gradle clean assembleDebug 打包完成后，将 Apk 安装到模拟器(adb install name.apk)，运行，log 如下： flavors_default: 109-17 22:43:55.390 19747-19747/com.littlejie.multichannel D/MainActivity: package name = com.littlejie.multichannel flavors_dev: 109-17 22:11:30.860 2638-2638/com.littlejie.multichannel.dev D/MainActivity: package name = com.littlejie.multichannel.dev flavors_release: 109-17 22:44:55.610 20650-20650/com.littlejie.multichannel.release D/MainActivity: package name = com.littlejie.multichannel.release 从这里可以看出，不同 flavor 的 package name 被 applicationId 替换掉了，而且同一个模拟器上可以同时安装以上三个应用。 下面我们再看看 AndroidManifest.xml 中发生了什么变化。这里需要用到 aapt 来查看 AndroidManifest.xml 的信息： 12//输出 apk 的 AndroidManifest.xml 文件的信息aapt dump xmltree ***.apk AndroidManifest.xml 关于 aapt 使用的更多用法，可以阅读这篇博文：使用 aapt 查看 apk 的各种信息 下面是 flavors_dev 版本的信息，可以看出 Java 源文件的包名并没有发生改变，而 package 属性的值被替换为 applicationId了。 如果在申请第三方 SDK 接入，则对应的包名应该填 applicationId ，而不是 AndroidManifest.xml 中的默认值 123456789101112131415161718192021222324252627lishengjiedeMacBook-Pro:apk littlejie$ aapt dump xmltree multichannel-flavors_dev-debug.apk AndroidManifest.xmlN: android=http://schemas.android.com/apk/res/android E: manifest (line=2) A: android:versionCode(0x0101021b)=(type 0x10)0x1 A: android:versionName(0x0101021c)=&quot;1.0&quot; (Raw: &quot;1.0&quot;) //此处 package 的值已替换成 applicationId 的值 A: package=&quot;com.littlejie.multichannel.dev&quot; (Raw: &quot;com.littlejie.multichannel.dev&quot;) A: platformBuildVersionCode=(type 0x10)0x18 (Raw: &quot;24&quot;) A: platformBuildVersionName=(type 0x4)0x40e00000 (Raw: &quot;7.0&quot;) E: uses-sdk (line=7) A: android:minSdkVersion(0x0101020c)=(type 0x10)0xf A: android:targetSdkVersion(0x01010270)=(type 0x10)0x18 E: application (line=11) A: android:theme(0x01010000)=@0x7f08008e A: android:label(0x01010001)=@0x7f060020 A: android:icon(0x01010002)=@0x7f030000 A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff A: android:allowBackup(0x01010280)=(type 0x12)0xffffffff A: android:supportsRtl(0x010103af)=(type 0x12)0xffffffff // Activity 的包名还是原来 AndroidManifest.xml 中申明的 E: activity (line=17) A: android:name(0x01010003)=&quot;com.littlejie.multichannel.MainActivity&quot; (Raw: &quot;com.littlejie.multichannel.MainActivity&quot;) E: intent-filter (line=18) E: action (line=19) A: android:name(0x01010003)=&quot;android.intent.action.MAIN&quot; (Raw: &quot;android.intent.action.MAIN&quot;) E: category (line=21) A: android:name(0x01010003)=&quot;android.intent.category.LAUNCHER&quot; (Raw: &quot;android.intent.category.LAUNCHER&quot;) applicationId 的原理可以理解为在 gradle 打包的时，动态合并属性，将 package 替换为 applicationId 指定的值，但并不会替换 Java 文件的包名，包括生成的 R 文件(可以去对应 module 下的 build/generated 目录下查看对应 flavor 的 R 文件)。 另外，由于最终生成的包中 AndroidManifest.xml 文件中的 package 属性被 applicationId 替换掉，故对于某些第三方 SDK ，如：微信、高德地图等需要验证包名的，就会碰到相当蛋疼的事，每个包都需要重新去生成 APPID 和 APPKEY，如果渠道很多，那么像微信就会出现问题微信账号申请的应用数就会超出微信的限制。 Android 官方文档原文如下： Therefore, we have decoupled the two usages of package name: The final package that is used in your built .apk’s manifest, and is the package your app is known as on your device and in the Google Play store, is the “application id”. The package that is used in your source code to refer to your R class, and to resolve any relative activity/service registrations, continues to be called the “package”. 补充：ApplicationId versus PackageName 替换 AndroidManifest.xml 中的属性这里可以参考友盟统计 SDK 中使用的方案。该方案通过在 AndroidManifest.xml 文件中 application 标签下指定 &lt;mate-data&gt; 设置占位符来实现动态替换属性值。 1&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"$&#123;UMENG_CHANNEL&#125;\" /&gt; 占位符形如${name}，在最终执行 AndroidManifest.xml 文件合并的时候，占位符会被 build.gradle 中对应值取代。 build.gradle 的配置需要用到上节讲到的 productFlavors 的 manifestPlaceholders 属性， manifestPlaceholders 属性直译过来就是清单文件占位符。 下面是 build.gradle 的节选代码： 123456789101112131415161718productFlavors &#123; //将 AndroidManifest.xml 文件中的 $&#123;UMENG_CHANNEL&#125; 替换为 default flavors_default &#123; manifestPlaceholders = [UMENG_CHANNEL: \"defalut\"] &#125; flavors_dev &#123; applicationId \"com.littlejie.multichannel.dev\" manifestPlaceholders = [UMENG_CHANNEL: \"dev\"] &#125; flavors_release &#123; applicationId \"com.littlejie.multichannel.release\" manifestPlaceholders = [UMENG_CHANNEL: \"release\"] &#125;&#125; 如果你要替换多个属性，则只需要将 manifestPlaceholders 的写法如下： 1manifestPlaceholders = [VALUE_NAME1 : \"value\" , VALUE_NAME2 : \"value\"] 补充：关于 AndroidManifest 文件合并规则可以查看 官方文档 替换资源文件多渠道打包的时候可能会碰到这种情况：每个应用市场的启动页图标、应用名称可能会有点小出入，更有甚者，连布局都不一样。这时候我们该怎么办呢？ 有一种解决办法就是：在代码里进行判断，根据渠道的不一样，加载不同的图片和布局，这是一种解决办法。但是当渠道有很多时，代码就会变得很难维护，而且指定渠道用到的资源文件都会被打入所有 Apk 中。所以这个方法并不值得推荐。那么，有什么好的解决办法呢？ 办法 Google 早就给我们想好了，而且相当简单，那就是：在 main 的同级目录下创建以渠道名命名的文件夹，然后创建资源文件（路径要与 main 中的一致），然后打包的时候 gradle 就会自己替换或者合并资源。 例如， App 的默认 icon 路径为 main\\res\\mipmap-hdpi\\ic_launcher.png ，那么 flavors_dev的路径就为 flavors_dev\\res\\mipmap-hdpi\\ic_launcher.png ，打包 flavors_dev 渠道的时候会自动替换图片。 对于资源合并，如果在 main 下的 strings.xml 内容为： 1234&lt;resources&gt; &lt;string name=\"app_name\"&gt;MultiChannel&lt;/string&gt; &lt;string name=\"string_merge\"&gt;我是string,我暂时没被合并&lt;/string&gt;&lt;/resources&gt; 在 flavors_dev 下的 strings.xml 内容为： 123&lt;resources&gt; &lt;string name=\"string_merge\"&gt;我是dev_string,我会把string合并&lt;/string&gt;&lt;/resources&gt; 当打 flavors_dev 渠道包时，最终 strings.xml 会变成： 1234&lt;resources&gt; &lt;string name=\"app_name\"&gt;MultiChannel&lt;/string&gt; &lt;string name=\"string_merge\"&gt;我是dev_string,我会把string合并&lt;/string&gt;&lt;/resources&gt; 以上特性可以用来替换 Apk 的应用名称和应用图标，这比使用前面讲到的占位符方便很多。同理，替换图片和合并颜色的原理也相似。 多渠道使用独立签名多渠道打包的时候，可能每个渠道包的签名都必须不一样，真正做到定制化，那么，怎么实现每个渠道包使用指定的签名呢？ 平时我们打包的时候是这样的： 123456789101112131415161718192021222324signingConfigs &#123; release &#123; storeFile file(\"签名文件路径\") storePassword \"storePassword\" keyAlias \"keyAlias\" keyPassword \"keyPassword\" &#125;&#125;buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' shrinkResources true //指定打 release 包时使用的签名文件 signingConfig signingConfigs.release &#125; //如果 debug 包需要测试诸如微信、地图等第三方 sdk ，则可以指定 debug 包使用 release 包的签名 //debug &#123; // signingConfig signingConfigs.release //&#125;&#125; 而给每个渠道包指定签名其实也差不多。 Google 官方原话： This enables either having all release packages share the same SigningConfig, by setting android.buildTypes.release.signingConfig, or have each release package use their own SigningConfig by setting each android.productFlavors.*.signingConfig objects separately. 大意就是，在 buildType 下指定签名的具体属性，形如 android.productFlavors.*.signingConfig signingConfigs.* ，前一个 * 指代在 productFlavors 中定义的 flavor ，后一个 * 指代在 signingConfigs 定义的属性。值得注意的是，signingConfigs 必须定义在 buildType 之前。 以下是 build.gradle 的配置节选： 123456789101112131415161718192021222324252627282930313233343536//定义签名属性signingConfigs &#123; flavors_default &#123; //如果签名文件在项目的根目录下,则可以这么写 storeFile file(\"../littlejie.jks\") storePassword \"******\" keyAlias \"******\" keyPassword \"*****\" &#125; flavors_dev &#123; storeFile file(\"../littlejie_dev.jks\") storePassword \"*****\" keyAlias \"*****\" keyPassword \"*****\" &#125;&#125;buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' shrinkResources true //多个 flavor ,指定 flavor 使用指定 签名 productFlavors.flavors_default.signingConfig signingConfigs.flavors_default productFlavors.flavors_dev.signingConfig signingConfigs.flavors_dev &#125; //如果 debug 包需要测试诸如微信、地图等第三方 sdk ，则可以指定 debug 包使用 release 包的签名 //debug 并不能设置多个签名 //debug &#123; // productFlavors.flavors_default.signingConfig signingConfigs.flavors_default // productFlavors.flavors_dev.signingConfig signingConfigs.flavors_dev //&#125;&#125; 下面我们来验证下生成的包的签名是否正确，查看签名我们会用到如下两个命令： 123456//查看签名文件的属性keytool -list -keystore 签名文件//查看 apk 的签名，需要提前解压 apk ，获取 CERT.RSA（位于解压目录下 /META-INF 下）//以下命令行是在 apk 解压目录下执行keytool -printcert -file META-INF/CERT.RSA 更多 keytool 命令使用可以查看 官方文档 首先，我们来看下 littlejie.jks 的信息： 12345678910lishengjiedeMacBook-Pro:AndroidDemo littlejie$ keytool -list -keystore littlejie.jks输入密钥库口令:密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目littlejie, 2016-9-18, PrivateKeyEntry,证书指纹 (SHA1): A2:B1:BF:BF:F1:F3:26:F4:FD:0C:94:95:B5:32:90:69:24:F7:99:84 解压 multichannel-flavors_default-release.apk ，查看 CERT.RSA 信息 1234567891011lishengjiedeMacBook-Pro:apk littlejie$ keytool -printcert -file multichannel-flavors_default-release/META-INF/CERT.RSA所有者: CN=littlejie发布者: CN=littlejie序列号: 71693e05有效期开始日期: Sun Sep 18 17:20:34 CST 2016, 截止日期: Thu Sep 12 17:20:34 CST 2041证书指纹: MD5: AC:12:83:51:44:FC:82:68:8B:23:7B:E9:12:24:AE:52 SHA1: A2:B1:BF:BF:F1:F3:26:F4:FD:0C:94:95:B5:32:90:69:24:F7:99:84 SHA256: AD:04:19:5F:92:00:0D:FA:7C:E5:8A:12:57:72:4C:1E:0E:2E:FC:0D:92:28:05:D0:CC:42:FC:93:95:44:88:88 签名算法名称: SHA256withRSA 版本: 3 可以发现两者的 SHA1 值是相等的。 同理，可以查看 littlejie_dev.jks 和 multichannel-flavors_dev-release.apk 的签名信息 123456789101112131415161718192021222324//littlejie_dev.jks 的签名信息lishengjiedeMacBook-Pro:AndroidDemo littlejie$ keytool -list -keystore littlejie_dev.jks输入密钥库口令:密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目littlejie, 2016-9-18, PrivateKeyEntry,证书指纹 (SHA1): B4:25:67:A5:9F:8C:1F:12:BD:85:6B:2D:FE:71:62:57:8A:CC:AE:E2//multichannel-flavors_dev-release.apk 的签名信息lishengjiedeMacBook-Pro:apk littlejie$ keytool -printcert -file multichannel-flavors_dev-release/META-INF/CERT.RSA所有者: CN=littlejie发布者: CN=littlejie序列号: 48346e15有效期开始日期: Sun Sep 18 17:21:23 CST 2016, 截止日期: Thu Sep 12 17:21:23 CST 2041证书指纹: MD5: 15:E9:E1:67:AB:33:8B:04:A4:C3:D0:05:8F:A6:35:37 SHA1: B4:25:67:A5:9F:8C:1F:12:BD:85:6B:2D:FE:71:62:57:8A:CC:AE:E2 SHA256: 96:A5:14:EC:28:25:32:0D:3E:D0:DB:D0:84:06:E7:9C:17:D7:91:83:A4:51:93:AB:34:3E:D9:FD:C5:FA:A1:8E 签名算法名称: SHA256withRSA 版本: 3 但是这里有个问题，就是这种给某个 flavor 指定签名的方法对 debug 无效，有兴趣的同学可以看上述注释掉的 debug 签名部分配置。简单来说，debug 签名只能指定一个或者使用默认的 debug 签名。 若哪位大神有解决方案，欢迎指出~ 这里再做几点补充： 多渠道使用独立签名，打包时千万不要使用 Android Studio 中 Build 菜单下的 Generate Signed APK，因为当你使用这个打包的时候， Android Studio 会让你指定使用的签名文件， so 你就等着哭吧~楼主因为这个折腾了半天。解决方法就是使用 gradle tasks。传送门：Android Gradle Build Tasks 鉴于第一点中的传送门需要翻墙，所以在这里简单介绍一下 Android Gradle Build Tasks 的使用。 打全部包： gradle assemble 打全部 Debug 包： gradle assembleDebug ，可以简写为 gradle aD ，前提是没有相同缩写的参数 打全部 Release 包： gradle assembleRelease，可以简写为 gradle aR 打指定 flavor 包： gradle assemble(flavor)(Debug|Release) 打包完成后安装（设备上没有安装该 apk ，否则会失败，而且只能指定 flavor ，不然也会失败）： gradle install(flavor)（Debug|Release） 打包前先 clean 一下(在测试的时候很必要，如果不 clean 的话，可能会导致某些小修改不会及时打入新包)： gradle clean assembleDebug 利用 Gradle 修改构建版本号楼主表示对 Groovy 不是很熟，所以利用 Gradle 自动修改构建版本这个就先留着，我先去研究几天~ 补充有童鞋在评论中说：使用 productFlavors 打包效率太低，的确是这样， gradle 好用是好用，就是打包效率低。如果只是单纯生成渠道包，建议使用美团多渠道打包方案，另外 360 加固也是一种不错的选择，效率都比使用 gradle 来的高。但如果需要替换 Apk 中的图片、字符串、应用的 applicationId 、给指定渠道的包使用指定的签名，那么只能乖乖使用 gradle 打包了，慢你也得忍着~ 之前刚开始调研的时候，发现 Github 上有个 ApkCustomizationTool 项目，它是通过对 Apk 解包，替换图片、字符串，然后重新签名，不过这毕竟是事后诸葛亮，控制在打包的源头总是毕竟好的，有兴趣的同学可以去研究下。 不知大家有没有这种感受，每次发版上传渠道的时候想死有没有？o(╯□╰)o 总结以上就是自己在使用 Gradle 实现 Android 多渠道打包时碰到的问题， Android 官方关于使用 Gradle 的文档已经很详细了，自己总结的只是一点皮毛，有时间要去自习研读下。 工作一年多，愣是没有写博客做总结，好多东西都是用过就忘，下次要用再找，没有成体系的 Android 知识结构，对工资不满意，可就连想跳槽面试都没底气。这次写这篇博客画了思维导图，自以为逻辑清晰了，可是真正要把这些东西讲述清楚，还真是一件麻烦的事~看来，自己还有很长的路要走~ 这段时间自己也在思考，是转行还是去考事业编制，还是继续做 Android。转行，除了编程自己好像别的什么也不会，当然自己编程也做的不怎么好。考事业编制，这个可以考虑，毕竟再很多人眼里这是个旱涝保收的职业。继续做 Android ，这个也不错，除了每次都花大把时间用来改 UI，别的都还不错（吐槽产品）。 话说，有没有什么工作，自由、上班时间少、工资高的？当然没有，至少现阶段的自己是接触不到的，所以，骚年，还是努力吧！多读书、多看报、多运动，少吃零食多睡觉~ 恩，算是对工作一年多的总结也是吐槽~ 读万卷书，行万里路~ 参考： Gradle Plugin User Guide Android Plugin DSL Reference Android Studio Gradle实践之多渠道自动化打包+版本号管理","categories":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/categories/Android/"},{"name":"Gradle","slug":"Android/Gradle","permalink":"http://www.littlejie.com/categories/Android/Gradle/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.littlejie.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://www.littlejie.com/tags/Gradle/"},{"name":"多渠道打包","slug":"多渠道打包","permalink":"http://www.littlejie.com/tags/多渠道打包/"}]}]}